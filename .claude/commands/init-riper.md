---
description: "Initialize RIPER workflow with code-first analysis and incremental updates"
allowed-tools: Read, Write, Edit, LS, Bash, Glob, Grep, WebSearch, WebFetch, TodoWrite
version: "5.0"
---

# RIPER Initialization Command v5.0

Use 4-Opus model, if Opus model is not available, this command will fallback to Sonnet for reliable performance.

**ultrathink** - This advanced initialization uses code-first analysis to ensure memory-bank accurately reflects actual implementation. Features incremental update strategy with systematic task planning, treating code as the single source of truth while preserving user content.

Initialize the RIPER memory-bank structure with incremental updates and quality assurance.

## Execution Strategy

**Incremental Update Approach**: File status assessment ‚Üí Selective information collection ‚Üí Targeted content generation ‚Üí Section-level auditing ‚Üí Precision correction

- **User Protection**: Preserve existing user content and customizations
- **Efficiency**: Only update files that need updating based on assessment
- **Quality**: Multi-stage auditing with complete template compliance verification
- **Safety**: Automatic backup before any modifications
- **Tracking**: TodoWrite-driven task management throughout process

## File Status Classification

```
MISSING: File does not exist ‚Üí Full generation required
EMPTY: File exists but contains only placeholders ‚Üí Full generation required  
PARTIAL: File exists but missing required template sections ‚Üí Incremental completion
OUTDATED: File complete but content appears stale ‚Üí Selective updates
CURRENT: File complete and content appears accurate ‚Üí Skip processing
```

## User Content Protection Strategy

**Custom Content Detection:**
- **Title-based**: Chapters with ## headers not in template
- **Position-based**: Content inserted between template sections
- **Format-based**: Sections without template emoji format

**Preservation Method:**
- Custom user sections automatically moved to end of file
- Template sections updated/added as needed
- User content preserved exactly as written

## Task Planning Framework

### **Phase 0: Pre-initialization (7 tasks)**
```
1. [PREP] Check existing CLAUDE.md status and memory-bank integration
2. [PREP] Scan memory-bank directory structure and existing œÉ files
3. [ASSESS] Evaluate existing œÉ files status (MISSING/EMPTY/PARTIAL/OUTDATED/CURRENT)
4. [BACKUP] Create safety backup of existing memory-bank files in backups/ directory  
5. [DETECT] Identify user custom content and mark for preservation
6. [PREP] Identify missing files and required updates to existing files
7. [PREP] Create directory structure for new files
```

### **Phase 1: Information Collection (12 parallel tasks)**

**üìã Project Foundation:**
```
8. [COLLECT] Extract project name, description, and core features from README.md
9. [COLLECT] Analyze CONTRIBUTING.md and docs/ for development standards
10. [COLLECT] Scan source code structure for main modules and entry points
11. [COLLECT] Analyze git history for project activity and key milestones
```

**üõ†Ô∏è Technical Intelligence:**
```
12. [COLLECT] Parse package.json/requirements.txt/Cargo.toml for tech stack
13. [COLLECT] Analyze source imports/includes for actual library usage
14. [COLLECT] Detect configuration files for databases, cloud services, deployment
15. [COLLECT] Examine build scripts for development commands and workflows
```

**üèóÔ∏è Architecture Analysis:**
```
16. [COLLECT] Analyze directory structure for architectural patterns
17. [COLLECT] Identify design patterns and naming conventions from code
18. [COLLECT] Examine error handling and logging strategies
19. [COLLECT] Assess testing approaches and quality assurance practices
```

### **Phase 1.5: Code-First Deep Analysis (15 tasks)**

**üîç Code Structure Analysis:**
```
20. [CODE-MAP] Create complete source code map using directory tree and file listing
21. [CODE-ENTRY] Identify main entry points (index.js, main.py, app.js, server.js, etc.)
22. [CODE-MODULES] Detect module boundaries from folder structure and import/export patterns
23. [CODE-COUPLING] Analyze inter-module dependencies via import/require statements
```

**üî¨ API & Interface Extraction:**
```
24. [CODE-ROUTES] Extract HTTP endpoints from Express/FastAPI/Spring/Rails routes
25. [CODE-GRAPHQL] Parse GraphQL schemas and resolvers if present
26. [CODE-GRPC] Extract gRPC service definitions from .proto files
27. [CODE-WEBSOCKET] Identify WebSocket event handlers and real-time channels
```

**üóÉÔ∏è Data Structure Mining:**
```
28. [CODE-MODELS] Extract database models (Mongoose/Sequelize/TypeORM/SQLAlchemy/ActiveRecord)
29. [CODE-TYPES] Parse TypeScript interfaces, type definitions, and JSDoc types
30. [CODE-SCHEMAS] Extract validation schemas (Joi/Yup/Zod/Pydantic/JSON Schema)
31. [CODE-MIGRATIONS] Analyze database migrations for schema evolution history
```

**üîß Configuration & Commands:**
```
32. [CODE-ENV] Extract environment variables usage from code (process.env/os.environ/ENV)
33. [CODE-CLI] Parse CLI argument definitions (commander/argparse/click/yargs)
34. [CODE-DEBUG] Search for debug flags, logging configurations, and trace points
```

### **Phase 2: Incremental Content Generation & Quality Control (40 tasks)**

**Each œÉ file follows: Generate/Update ‚Üí Audit ‚Üí Structure Check ‚Üí Correct ‚Üí Confirm**

**œÉ‚ÇÅ Project Brief (5 tasks):**
```
35. [UPDATE-œÉ‚ÇÅ] Generate/update projectbrief.md based on file status assessment
36. [AUDIT-œÉ‚ÇÅ] Verify project description accuracy and requirement completeness
37. [STRUCT-œÉ‚ÇÅ] Verify complete template compliance: ‚úìContains ALL required sections (Overview, Requirements, Goals & Objectives, Cross-References) ‚úìNo missing chapters ‚úìNo extra non-template sections ‚úìCorrect section order ‚úìProper header format with emojis
38. [FIX-œÉ‚ÇÅ] Correct any inaccurate descriptions, missing objectives, or structural deviations
39. [CONFIRM-œÉ‚ÇÅ] Final validation of goals alignment and cross-references
```

**œÉ‚ÇÇ System Patterns - Lightweight (5 tasks):**
```
40. [UPDATE-œÉ‚ÇÇ] Generate/update systemPatterns.md with lightweight architecture + module index
41. [AUDIT-œÉ‚ÇÇ] Verify architecture overview accuracy and module boundary identification
42. [STRUCT-œÉ‚ÇÇ] Verify template compliance: ‚úìArchitecture Overview ‚úìSystem Data Flow ‚úìDesign Patterns ‚úìModule Structure (with @modules/ refs) ‚úìTDD Planning Storage ‚úìCross-References
43. [FIX-œÉ‚ÇÇ] Correct architecture misidentification or module organization issues
44. [CONFIRM-œÉ‚ÇÇ] Validate architecture clarity and module index completeness
```

**Modules Structure Generation (10 tasks):**
```
45. [ANALYZE-MODULES] Identify project modules from source code structure and imports
46. [CREATE-MODULES-DIR] Create memory-bank/modules/ directory structure
47. [GENERATE-MODULE-1] Generate modules/[identified-module-1]/design.md based on project analysis
48. [GENERATE-MODULE-2] Generate modules/[identified-module-2]/design.md based on project analysis
49. [GENERATE-MODULE-3] Generate modules/[identified-module-3]/design.md based on project analysis
50. [GENERATE-MODULE-N] Generate additional module design files as needed
51. [VALIDATE-MODULES] Ensure each module has proper LLD detail for Œ©‚ÇÇ·¥¨ Architecture Critic
52. [CROSS-LINK-MODULES] Add inter-module dependency references
53. [AUDIT-MODULES] Verify each module design.md contains: Core Responsibilities, Key Interfaces, Data Structures, Technical Decisions
54. [UPDATE-MODULE-REFS] Update œÉ‚ÇÇ systemPatterns.md with correct @modules/ references
```

**Project-Level CLAUDE.md (5 tasks):**
```
55. [ANALYZE-PROJECT] Extract project-specific tech stack, commands, and conventions
56. [GENERATE-CLAUDE-MD] Create project-level CLAUDE.md with Tech Stack, Project Structure, Commands, Code Style, Do Not, Memory Integration
57. [VALIDATE-COMMANDS] Verify build/test/run commands are project-specific and functional
58. [AUDIT-CLAUDE-MD] Ensure CLAUDE.md contains memory-bank integration references
59. [CONFIRM-CLAUDE-MD] Final validation of project-level constraints and team conventions
```

**œÉ‚ÇÉ Technical Context (5 tasks):**
```
60. [UPDATE-œÉ‚ÇÉ] Generate/update techContext.md based on file status assessment
61. [AUDIT-œÉ‚ÇÉ] Verify technology stack accuracy and dependency completeness
62. [STRUCT-œÉ‚ÇÉ] Verify complete template compliance: ‚úìContains ALL required sections (Technology Stack with 5 categories, Dependencies with Core/Dev subsections, Cross-References) ‚úìNo missing chapters ‚úìNo extra non-template sections ‚úìCorrect section order ‚úìProper technology categorization
63. [FIX-œÉ‚ÇÉ] Correct technology misidentifications, missing dependencies, or structural deviations
64. [CONFIRM-œÉ‚ÇÉ] Validate tech stack relevance and version accuracy
```

**œÉ‚ÇÑ Active Context (5 tasks):**
```
65. [UPDATE-œÉ‚ÇÑ] Generate/update activeContext.md based on file status assessment
66. [AUDIT-œÉ‚ÇÑ] Verify context references validity and state initialization
67. [STRUCT-œÉ‚ÇÑ] Verify complete template compliance: ‚úìContains ALL required sections (Current Focus, Context References, Context Status, RIPER Agent State, Agent Handoff, Mode History, Cross-References) ‚úìNo missing chapters ‚úìNo extra non-template sections ‚úìCorrect section order ‚úìProper agent state format
68. [FIX-œÉ‚ÇÑ] Correct invalid references, agent state configuration, or structural issues
69. [CONFIRM-œÉ‚ÇÑ] Validate context relevance and handoff mechanisms
```

**œÉ‚ÇÖ Progress Tracker (5 tasks):**
```
70. [UPDATE-œÉ‚ÇÖ] Generate/update progress.md based on file status assessment
71. [AUDIT-œÉ‚ÇÖ] Verify milestone relevance and task categorization logic
72. [STRUCT-œÉ‚ÇÖ] Verify complete template compliance: ‚úìContains ALL required sections (Project Status, Completed Tasks, In Progress, Pending Tasks, Milestones, Cross-References) ‚úìNo missing chapters ‚úìNo extra non-template sections ‚úìCorrect section order ‚úìProper task list format
73. [FIX-œÉ‚ÇÖ] Adjust milestones, refine task organization, or fix structural deviations
74. [CONFIRM-œÉ‚ÇÖ] Validate progress tracking alignment with project goals
```

**œÉ‚ÇÜ Protection Registry (5 tasks):**
```
75. [UPDATE-œÉ‚ÇÜ] Generate/update protection.md based on file status assessment
76. [AUDIT-œÉ‚ÇÜ] Verify protection classifications and critical file identification
77. [STRUCT-œÉ‚ÇÜ] Verify complete template compliance: ‚úìContains ALL required sections (Protected Regions, Critical Files, Protected Functions, Protection History, Approvals, Permission Violations, Cross-References) ‚úìNo missing chapters ‚úìNo extra non-template sections ‚úìCorrect section order ‚úìProper protection classification format
78. [FIX-œÉ‚ÇÜ] Refine protection levels, add missing critical elements, or fix structural issues
79. [CONFIRM-œÉ‚ÇÜ] Validate protection registry completeness and accuracy
```

### **Phase 3: Integration & Final Validation (15 tasks)**
```
80. [INTEGRATE] Verify all œÉ‚ÇÅ-œÉ‚ÇÜ cross-references are valid and complete
81. [VALIDATE-MODULE-REFS] Verify all @modules/ references in œÉ‚ÇÇ point to existing design.md files
82. [XREF-UPDATE] Update cross-references that point to renamed or restructured sections
83. [VALIDATE] Ensure placeholder replacement completeness ({DATE}, {PHASE}, {MODE})
84. [VERIFY-CLAUDE-MD] Confirm project-level CLAUDE.md memory-bank integration links are functional
85. [VERIFY-GLOBAL] Confirm global CLAUDE.md memory-bank integration links are functional
86. [CHECK] Validate RIPER Agent State initialization and session setup
87. [META-CHECK] Verify metadata consistency across all œÉ files and modules (version, date, phase, mode)
88. [QUALITY-CHECK-CORE] Ensure all core œÉ files have actual content (no empty placeholders)
89. [QUALITY-CHECK-MODULES] Ensure all module design.md files have complete sections
90. [FORMAT-CHECK] Validate Markdown format standardization and emoji consistency
91. [MODULE-INDEX-CHECK] Verify œÉ‚ÇÇ module index accuracy and completeness
92. [PROJECT-CLAUDE-CHECK] Verify project-level CLAUDE.md contains all required sections
93. [REPORT] Generate initialization summary and quality assessment with change log
94. [FINALIZE] Create/update symbols.md reference guide
```

## Quality Assurance Features

### **Built-in Quality Checks:**
- **Code-First Verification**: Code implementation as single source of truth
- **Accuracy Verification**: Technology stack vs actual dependencies
- **Completeness Validation**: All template sections properly filled
- **Consistency Auditing**: Cross-reference integrity across all œÉ files
- **Context Relevance**: Generated content matches actual project characteristics
- **User Protection**: Custom user content preserved and repositioned

### **Error Correction Strategy:**
- **Targeted Fixes**: Only correct identified errors, preserve accurate content
- **Source Re-analysis**: Re-examine original files for correction information
- **Incremental Updates**: Apply fixes without disrupting correct sections
- **User Content Preservation**: Move custom sections to end, never delete
- **Validation Loops**: Confirm corrections resolve identified issues

### **Backup & Safety Mechanisms:**
- **Automatic Backup**: All existing files backed up to memory-bank/backups/ before modification
- **File Archiving**: Changed files archived with timestamp for recovery
- **Error Recovery**: Partial failure handling with ability to resume or rollback

## Information Source Marking System

### **Source Reliability Indicators:**
```
[FROM:code] - Directly extracted from source code (100% reliable)
[FROM:test] - Inferred from test files (95% reliable)
[FROM:config] - Extracted from configuration files (85% reliable)
[FROM:doc] - Only found in documentation (40% reliable)
[CODE-TRUTH] - Code implementation takes precedence
[DOC-CONFLICT] - Documentation conflicts with code
[CODE-MISSING] - Documented but not found in code
[INFERRED] - Deduced from code structure/patterns
[TODO] - Information missing, needs manual input
```

### **Conflict Resolution Rules:**
1. **Code Always Wins**: Implementation is the single source of truth
2. **Mark All Conflicts**: Clearly identify documentation vs code discrepancies
3. **Preserve Context**: Keep documentation content but mark as potentially outdated
4. **Version Tracking**: Include extraction timestamp for traceability

## Incremental Update Logic

### **File Processing Decision Tree:**
```
For each œÉ file:
‚îú‚îÄ‚îÄ Status = MISSING ‚Üí Full generation with template
‚îú‚îÄ‚îÄ Status = EMPTY ‚Üí Full generation with collected info
‚îú‚îÄ‚îÄ Status = PARTIAL ‚Üí Add missing sections, preserve existing
‚îú‚îÄ‚îÄ Status = OUTDATED ‚Üí Update stale content, preserve structure
‚îî‚îÄ‚îÄ Status = CURRENT ‚Üí Skip processing, preserve as-is
```

### **Update Granularity:**
- **Section-level**: Update individual template sections as needed
- **Content-preserving**: Never overwrite user customizations
- **Structure-completing**: Add missing template sections
- **Reference-updating**: Fix broken cross-references

## Memory Bank Templates

**œÉ‚ÇÅ projectbrief.md:** # œÉ‚ÇÅ: Project Brief\n*v1.0 | Created: {DATE} | Updated: {DATE}*\n*Œ†: {PHASE} | Œ©: {MODE}*\n\n## üèÜ Overview\n[Project description]\n\n## üìã Requirements\n- [R‚ÇÅ] [Requirement 1]\n- [R‚ÇÇ] [Requirement 2]\n- [R‚ÇÉ] [Requirement 3]\n\n## üéØ Goals & Objectives\n- [G‚ÇÅ] [Goal 1]\n- [G‚ÇÇ] [Goal 2]\n- [G‚ÇÉ] [Goal 3]\n\n## üîó Cross-References\n- Architecture: [‚ÜóÔ∏èœÉ‚ÇÇ:Architecture]\n- Tech Stack: [‚ÜóÔ∏èœÉ‚ÇÉ:Technologies]\n- Progress: [‚ÜóÔ∏èœÉ‚ÇÖ:Status]

**œÉ‚ÇÇ systemPatterns.md (Lightweight):** # œÉ‚ÇÇ: System Patterns\n*v1.0 | Created: {DATE} | Updated: {DATE}*\n*Œ†: {PHASE} | Œ©: {MODE}*\n\n## üèõÔ∏è Architecture Overview\n[System architecture description - layered/microservices/monolithic approach]\n\n## üìä System Data Flow\n[High-level data flow between major components]\n\n## üìê Design Patterns\n- [Core Pattern 1]: [Brief description]\n- [Core Pattern 2]: [Brief description]\n- Test-First Development: Design guided by test requirements\n- Interface Segregation: Clear boundaries between test and implementation\n\n## üèóÔ∏è Module Structure\n[Dynamic module list based on project analysis]\n- @modules/[module-name]/ - [Module description]\n\n## üìù Code Conventions\n### Basic Standards\n- Language: [Primary language] + [Version]\n- Style: [Style guide reference]\n- Testing: [Test file patterns]\n- Error Handling: [Error handling approach]\n\n## üîÑ TDD Planning Storage\n### TDD Cycles\nœÉ‚ÇÇ.tdd_cycles: []  # TDD cycle plan list\n\n### Architecture Design\nœÉ‚ÇÇ.architecture_design: null  # From Œ©‚ÇÅ·¥æ CC Plan Mode\n\n### Module Specifications\nœÉ‚ÇÇ.module_specifications: {}  # Detailed module designs\n\n### Tech Stack\nœÉ‚ÇÇ.tech_stack: null  # Technology choices\n\n## üîó Cross-References\n- Tech Context: [‚ÜóÔ∏èœÉ‚ÇÉ:Stack]\n- Project Brief: [‚ÜóÔ∏èœÉ‚ÇÅ:Requirements]\n- Active Context: [‚ÜóÔ∏èœÉ‚ÇÑ:TDD_State]\n- Module Details: @modules/[module-name]/design.md

**œÉ‚ÇÉ techContext.md:** # œÉ‚ÇÉ: Technical Context\n*v1.0 | Created: {DATE} | Updated: {DATE}*\n*Œ†: {PHASE} | Œ©: {MODE}*\n\n## üõ†Ô∏è Technology Stack\n- üñ•Ô∏è Frontend: [Technologies]\n- üîô Backend: [Technologies]\n- üíæ Database: [Technologies]\n- ‚òÅÔ∏è Cloud: [Technologies]\n- üîß DevOps: [Technologies]\n\n## üì¶ Dependencies\n### Core Dependencies\n- Dependency 1: version\n- Dependency 2: version\n- Dependency 3: version\n\n### Development Dependencies\n- Dev Dep 1: version\n- Dev Dep 2: version\n- Dev Dep 3: version\n\n## üîó Cross-References\n- System Patterns: [‚ÜóÔ∏èœÉ‚ÇÇ:Architecture]\n- Project Brief: [‚ÜóÔ∏èœÉ‚ÇÅ:Overview]

**œÉ‚ÇÑ activeContext.md:** # œÉ‚ÇÑ: Active Context\n*v1.0 | Created: {DATE} | Updated: {DATE}*\n*Œ†: {PHASE} | Œ©: {MODE}*\n\n## üîÆ Current Focus\n[Current focus]\n\n## üìé Context References\n- üìÑ Active Files: []\n- üíª Active Code: []\n- üìö Active Docs: []\n- üìÅ Active Folders: []\n- üîÑ Git References: []\n- üìè Active Rules: []\n- üß™ TDD Cycles: []\n- üî¥ Test Files: []\n- üü¢ Implementation Files: []\n\n## üì° Context Status\n- üü¢ Active: []\n- üü° Partially Relevant: []\n- üü£ Essential: []\n- üî¥ Deprecated: []\n\n## ü§ñ RIPER Agent State\nŒ©_current: Œ©‚ÇÅ·¥æ              # Current RIPER mode (Œ©‚ÇÅ·¥æ|Œ©‚ÇÇ·¥¨|Œ©‚ÇÉ·¥æ|Œ©‚ÇÑ·∂ú|Œ©‚ÇÖ·µÄ|Œ©‚ÇÜ‚±Ω)\nŒ©_session: AGT_2025_001     # Agent lifecycle identifier\nsession_id: null            # MCP Memory dialogue session (Plan‚ÜîCritic)\ntdd_session_id: null        # MCP Memory dialogue session (QA‚ÜîDE)\nplan_approved: false        # Œ©‚ÇÑ·∂ú Plan Critic approval\ndesign_approved: false      # Œ©‚ÇÇ·¥¨ Architecture Critic approval\narch_critique: null         # Architecture critique result\nŒ©_transitions: []           # Mode transition history\n\n# TDD Execution State\ntdd_mode: false             # TDD mode enabled (Œ©‚ÇÖ·µÄ)\ntdd_phase: null             # current: 'red'|'green'|'refactor'\ncurrent_cycle: 0            # active iteration index\ntarget_method: null         # method being developed\nqa_agent_active: false      # QA role active\nde_agent_active: false      # DE role active\nlast_test_result: null      # 'pass'|'fail'|null\nrefactor_stage: null        # test|impl|qa_validation|de_validation|qa_cross_review|de_cross_review|interface_check|integration_test\n\n## ü§ù Agent Handoff\nhandoff_from: null          # Previous mode\nhandoff_to: null            # Expected next mode\nhandoff_summary: |          # Context for next agent\n  [Handoff details here]\nhandoff_timestamp: null\n\n## üìä Mode History\n| Time | From | To | Trigger | Summary |\n|------|------|----|---------|---------|  \n| -    | -    | -  | -       | -       |\n\n## üîó Cross-References\n- Brief: [‚ÜóÔ∏èœÉ‚ÇÅ:Overview]\n- Patterns: [‚ÜóÔ∏èœÉ‚ÇÇ:Architecture]\n- Tech: [‚ÜóÔ∏èœÉ‚ÇÉ:Stack]\n- Progress: [‚ÜóÔ∏èœÉ‚ÇÖ:Status]\n- Protection: [‚ÜóÔ∏èœÉ‚ÇÜ:Registry]

**œÉ‚ÇÖ progress.md:** # œÉ‚ÇÖ: Progress Tracker\n*v1.0 | Created: {DATE} | Updated: {DATE}*\n*Œ†: {PHASE} | Œ©: {MODE}*\n\n## üìà Project Status\nCompletion: 0%\nCurrent Phase: {PHASE}\nCurrent Mode: {MODE}\nTDD Mode: false\nTDD Cycles Completed: 0/0\n\n## ‚úÖ Completed Tasks\n- [ ] Task 1\n- [ ] Task 2\n- [ ] Task 3\n\n## üß™ TDD Cycle Progress\n### Completed Cycles\n- [ ] Cycle 1: [method_name] (‚Ñú‚Üí‚Ñú·¥≥‚Üí‚Ñú·∂†) ‚úì\n- [ ] Cycle 2: [method_name] (‚Ñú‚Üí‚Ñú·¥≥‚Üí‚Ñú·∂†) ‚úì\n\n### Current Cycle\n- [ ] Cycle N: [method_name]\n  - [ ] RED Phase (QA): Write failing tests\n  - [ ] GREEN Phase (DE): Minimal implementation\n  - [ ] REFACTOR Phase: Quality improvement\n\n### Pending Cycles\n- [ ] Cycle N+1: [method_name] ‚Üí ‚Ñú‚Üí‚Ñú·¥≥‚Üí‚Ñú·∂†\n- [ ] Cycle N+2: [method_name] ‚Üí ‚Ñú‚Üí‚Ñú·¥≥‚Üí‚Ñú·∂†\n\n## üöß In Progress\n- [ ] Current Task 1\n- [ ] Current Task 2\n\n## üìã Pending Tasks\n- [ ] Future Task 1\n- [ ] Future Task 2\n\n## üèÅ Milestones\n- [ ] Milestone 1\n- [ ] Milestone 2\n- [ ] Milestone 3\n- [ ] TDD Integration Complete\n- [ ] All Cycles Verified\n\n## üìä Quality Metrics\n- Test Coverage: 0%\n- Cycles with Refactor: 0/0\n- Failed Cycles: 0\n- Refactor Improvements Made: 0\n\n## üîó Cross-References\n- Active Context: [‚ÜóÔ∏èœÉ‚ÇÑ:Focus]\n- Project Brief: [‚ÜóÔ∏èœÉ‚ÇÅ:Goals]\n- TDD State: [‚ÜóÔ∏èœÉ‚ÇÑ:TDD_Execution_State]

**œÉ‚ÇÜ protection.md:** # œÉ‚ÇÜ: Protection Registry\n*v1.0 | Created: {DATE} | Updated: {DATE}*\n*Œ†: {PHASE} | Œ©: {MODE}*\n\n## üõ°Ô∏è Protected Regions\n[Protected code registry]\n\n### Critical Files\n- File 1: [Protection reason]\n- File 2: [Protection reason]\n\n### Protected Functions\n- Function 1: [Protection reason]\n- Function 2: [Protection reason]\n\n## üìú Protection History\n[History and changes]\n\n## ‚úÖ Approvals\n[Modification approvals]\n\n## ‚ö†Ô∏è Permission Violations\n[Violation logs]\n\n## üîó Cross-References\n- Active Context: [‚ÜóÔ∏èœÉ‚ÇÑ:Status]\n- System Patterns: [‚ÜóÔ∏èœÉ‚ÇÇ:Architecture]

**symbols.md:** # üî£ Symbol Reference Guide\n*v1.0 | Created: {DATE} | Updated: {DATE}*\n\n## üìÅ File Symbols\n- üìÇ = /memory-bank/\n- üì¶ = /memory-bank/backups/\n- üìÑ = .md files\n- üìä = data files\n- üìã = configuration files\n\n## ü§ñ RIPER Symbols\n- Œ©‚ÇÅ·¥æ = CC Plan Mode (architecture & module design)\n- Œ©‚ÇÇ·¥¨ = Architecture Critic (dual-layer audit Œõ‚ÇÅ|Œõ‚ÇÇ)\n- Œ©‚ÇÉ·¥æ = Plan Mode (implementation specification)\n- Œ©‚ÇÑ·∂ú = Plan Critic (feasibility validation)\n- Œ©‚ÇÖ·µÄ = TDD Execute (QA‚ÜîDE collaboration)\n- Œ©‚ÇÜ‚±Ω = Review Mode (final validation)\n  ‚îî‚îÄ TDD Phases: Œ©‚ÇÖ·¥ø=RED, Œ©‚ÇÖ·¥≥=GREEN, Œ©‚ÇÖ·∂†=REFACTOR\n\n## üìö Memory Symbols\n- œÉ‚ÇÅ = projectbrief.md (requirements)\n- œÉ‚ÇÇ = systemPatterns.md (architecture + TDD cycles)\n- œÉ‚ÇÉ = techContext.md (technology stack)\n- œÉ‚ÇÑ = activeContext.md (state + sessions)\n- œÉ‚ÇÖ = progress.md (tracking)\n- œÉ‚ÇÜ = protection.md (registry)\n\n## üîó Reference Symbols\n- [‚ÜóÔ∏èœÉ‚Çì:R‚Çì] = Cross-reference to memory file section\n- Œì‚ÇÅ = Files, Œì‚ÇÇ = Folders, Œì‚ÇÉ = Code\n- Œì‚ÇÑ = Commands, Œì‚ÇÖ = Modify, Œì‚ÇÜ = Web\n\n## üõ°Ô∏è Protection Symbols\n- Œ®‚ÇÅ-‚ÇÉ = Proceed (Low risk)\n- Œ®‚ÇÑ-‚ÇÜ = Caution + Confirm (High risk)\n\n## üîÑ Session Types\n- Œ©_session = Agent lifecycle ID (persists across modes)\n- session_id = Plan‚ÜîCritic dialogue (MCP Memory)\n- tdd_session_id = QA‚ÜîDE dialogue (per TDD cycle)

**modules/[module-name]/design.md:** # [ModuleName] Module Design\n*v1.0 | Created: {DATE} | Updated: {DATE}*\n*Module: [module-name] | Status: [design|development|testing|complete]*\n\n## üéØ Core Responsibilities\n- [Primary responsibility 1]\n- [Primary responsibility 2]\n- [Primary responsibility 3]\n\n## üîó Key Interfaces\n### Public APIs\n```\n[Interface/API definitions]\n```\n### Internal Interfaces\n```\n[Internal interface definitions]\n```\n\n## üìä Data Structures\n### Primary Models\n```\n[Core data structures/models]\n```\n### State Management\n[State management approach if applicable]\n\n## ‚öôÔ∏è Technical Decisions\n### Architecture Choices\n- [Decision 1]: [Reasoning]\n- [Decision 2]: [Reasoning]\n### Dependencies\n- Internal: [List internal module dependencies]\n- External: [List external library dependencies]\n\n## üîÑ Integration Points\n- Input: [What this module receives]\n- Output: [What this module produces]\n- Events: [Events this module emits/listens to]\n\n## üß™ Testing Strategy\n[Module-specific testing approach and key test scenarios]

**Project-Level CLAUDE.md:** # Tech Stack\n- Language: [Primary Language] [Version]\n- Framework: [Main Framework/Library]\n- Testing: [Testing Framework]\n- Database: [Database if applicable]\n- Build: [Build system]\n\n# Project Structure\n```\n[Project directory structure]\n```\n\n# Commands\n- `[build-command]`: Build the project\n- `[test-command]`: Run test suite\n- `[dev-command]`: Start development server\n- `[lint-command]`: Run linter/formatter\n- `[deploy-command]`: Deploy application\n\n# Debugging\n## Debug Commands [FROM:code]\n- `[debug-command]`: Enable debug mode [FROM:package.json|main.py|etc]\n- Common debug flags discovered in code\n- Environment variables for debugging\n\n## Debug Tools [FROM:config]\n- Development tools configuration\n- Logger settings and levels\n- Trace and profiling options\n\n# TDD-RIPER Integration\n**IMPORTANT**: This project uses TDD-RIPER workflow\n- Read memory-bank files before starting any work\n- Follow memory-bank/progress.md for current TDD cycles\n- All design decisions recorded in memory-bank/systemPatterns.md\n\n# Code Style\n- [Language-specific conventions]\n- [Naming conventions]\n- [File organization rules]\n- [Testing patterns]\n\n# Do Not\n- Skip TDD phases (Red‚ÜíGreen‚ÜíRefactor)\n- Maintain design decisions outside memory-bank\n- [Project-specific constraints]\n\n# Memory Integration\nProject memory stored in:\n- Brief: memory-bank/projectbrief.md\n- Architecture: memory-bank/systemPatterns.md\n- Tech Stack: memory-bank/techContext.md\n- Current State: memory-bank/activeContext.md\n- Progress: memory-bank/progress.md\n- Protection: memory-bank/protection.md\n- Module Details: memory-bank/modules/[module]/design.md\n\n**Start every session by reading relevant memory-bank files**

## Implementation Instructions

**Module Generation Logic:**
1. Scan project structure to identify functional modules
2. Create memory-bank/modules/[module-name]/ directories
3. Generate design.md for each identified module
4. Update œÉ‚ÇÇ systemPatterns.md with @modules/ references

**Project-Level CLAUDE.md Generation:**
1. Replace any existing CLAUDE.md (not append)
2. Extract actual tech stack from project files
3. Identify real build/test commands from package.json/Makefile/etc
4. Generate project-specific constraints and conventions

**Quality Assurance:**
- Verify all @modules/ references in œÉ‚ÇÇ point to existing files
- Ensure project-level CLAUDE.md contains memory-bank integration
- Validate module design.md files contain all required sections
- Confirm œÉ‚ÇÇ systemPatterns.md stays under 3000 characters

**This enhanced version provides:**
- Code-first architecture discovery with implementation as single source of truth
- Automatic API endpoint extraction from route definitions
- Debug command and flag discovery from code analysis
- Intelligent module boundary detection from import patterns
- Data structure mining from models and schemas
- Documentation vs code conflict detection and marking
- Modular memory-bank architecture with lightweight core files
- Module-specific design documents in memory-bank/modules/
- Project-level CLAUDE.md generation with TDD-RIPER integration
- Incremental update strategy with user content protection
- Systematic task planning with 94 structured tasks (was 79)
- Quality assurance through multi-stage auditing
- Complete template compliance verification
- Automatic backup and safety mechanisms
- Cross-reference integrity management including @modules/ references
- Error correction with targeted fixes
- Progress tracking via TodoWrite integration
- Improved content accuracy through code analysis
- Information source tracking with reliability indicators

**Expected outcomes:**
- Code-accurate memory-bank reflecting actual implementation
- Automatic discovery of debugging methods and tools
- Clear marking of information sources and reliability
- Documentation conflicts visible but not disruptive
- Modular memory-bank architecture preventing œÉ‚ÇÇ overload
- Higher quality memory-bank initialization with user protection
- Significantly fewer manual corrections required
- Preserved user customizations and enhancements
- Better project context capture through code analysis
- Reliable cross-reference integrity and structure compliance
- Project-specific CLAUDE.md with actual commands from code
- 95%+ alignment between memory-bank and implementation